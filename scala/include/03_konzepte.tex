\chapter{Konzepte}

\section{Variablen}

Scala kennt zwei Keywords, um Variablen zu definieren: \emph{val} und 
\emph{var}. Der Unterschied besteht darin, dass eine Variable, die mit
\emph{val} definiert wurde, nicht mehr verändert werden kann. \emph{val}
ist also ähnlich wie eine \emph{final}-Variable in Java.

\section{Objektorientierung}

\subsection{Singleton-Objekte}

Da Scala eine Objektorientierte Programmiersprache ist, können nebst
den eingebauten Datentypen (\ref{sec:datatypes}) auch Klassen oder
Objekte definiert werden. Klassen haben die gleiche Funktionalität
wie in Java, mehr dazu unter \ref{sec:classes}.  Anders als in Java
ist die Möglichkeit, direkt Objekte zu definieren.  Dies kann mit dem
\emph{object}-Keyword erreicht werden, und entspricht dem Konzept des
allgemein bekannten Singleton-Pattern (es kann also nur eine Instanz davon
geben). Diese einmalige Instanz eines solchen Objekts wird beim ersten
Gebrauch automatisch kreiert. Ein wichtiger Unterschied zu Klassen ist,
dass ein solches Singleton-Objekt keine Parameter entgegen nehmen kann,
da es nicht manuell instanziert werden kann.

Ein Keyword wie \emph{static} in Java gibt es nicht. Anstatt Methoden
statisch zu implementieren, ist es in Scala üblich, Singleton-Objekte
zu definieren.\\

Ein Beispiel eines einfachen Singleton-Objekts bietet das Listing
\ref{lst:helloWorld} im Kapitel \ref{sec:helloWorld}.

\subsection{Klassen}
\label{sec:classes}

\subsubsection{Deklaration und Konstruktoren}

Klassen werden in einer Syntax deklariert die der von Java recht
ähnlich ist. Der Klassen-Body kann dabei dazu verwendet werden,
um Operationen bei der Instanzierung der Klasse auszuführen. In Java
wird dazu eine Konstruktor-Methode benötigt, in Scala hingegen können
diese Operationen einfach unter den Klassennamen geschrieben werden. \\

Ein Beispiel einer einfachen Klasse mit Konstruktor in Java
\lstset{float=ht,language=java,caption={Java-Konstruktor},label=lst:javaConstructor}
\lstinputlisting{src/Constructing.java}

würde in Scala wie folgt aussehen:
\lstset{float=ht,language=scala,caption={Scala-Konstruktor},label=lst:scalaConstructor}
\lstinputlisting{src/Constructing.scala}

Dies wird der \emph{primary constructor} benannt. Dem Programmierer steht es 
frei, noch weitere Konstruktoren zu definieren.


\subsubsection{Instanzierung}

Die Instanzierung von Klassen erfolgt analog zur Java-Syntax. So würde das 
Konstruktor-Beispiel im vorigen Kapitel (\ref{lst:scalaConstructor}) wie 
folgt instanziert werden:

\lstset{float=ht,language=scala,caption={Scala-Konstruktor},label=lst:scalaConstructor}
\lstinputlisting{src/TestConstructing.scala}

\subsubsection{Komposition und Vererbung}

Scala bietet alle nötigen Instrumente, um Klassen zu vererben und Subtypen
zu erstellen. Ebenfalls erstellt werden können abstrakte Klassen, finale
Klassen sowie finale Variablen. Ebenso möglich ist, die sichtbarkeit von 
Klassenmember mit \emph{private} oder \emph{protected} einzuschränken. 
Kenner von Java finden sich mit den entsprechenden Keywords für diese
Konzepte schnell zurecht.\\

Ein Keyword, welches in Scala zusätzlich anzutreffen ist, ist 
\emph{override}. Falls ein Klassen-Member überschrieben werden soll,
muss dieses Keyword vor die Definition gestellt werden. Dies macht
ein versehentliches Überschreiben von Klassen-Member unmöglich.\\

Ein Umfangreiches Beispiel von Klassenvererbung und Komposition bietet
Beispiel TODO beispiel

\subsection{Traits}

Ein Konzept, das beim Vergleich mit Java zu fehlen scheint, sind 
Interfaces. Scala bietet hierfür jedoch Traits, welche
den Interfaces nicht unähnlich sind. Traits können wie Klassen
vererbt werden, was als \glqq mixin\grqq \footnote{Vom Englischen \emph{to mix in}}
bezeichnet wird. Der hauptsächliche Unterschied zu Interfaces besteht 
darin, dass Traits bereits implementation von Methoden enthalten
können. Jedoch können sie keine Konstruktor-Parameter enthalten. \\

Es dürfen mehrere Traits in eine Klasse \glqq gemischt\grqq werden. Dies
ähnelt der Mehrfachvererbung von z.B. c++. Im Gegensatz dazu können
jedoch mit Traits Probleme
\footnote{Das Diamond-Problem 
\href{http://de.wikipedia.org/wiki/Diamond-Problem}
{http://de.wikipedia.org/wiki/Diamond-Problem}} vermieden werden, die 
normalerweise bei Mehrfachvererbung auftauchen. Eine genaue Abhandlung
hierzu würde jedoch dieses Dokument sprengen.

\section{Funktionale Konzepte}

\subsection{Funktionen als Objekte und anonyme Funktionen}
\label{sec:functionsObjects}

Eines der grundlegenden Konzepte aus der Funktionalen Programmierung ist,
dass Funktionen auch Objekte sind. Dies macht es möglich, Funktionen
in Variablen zu speichern, sie als Argument an Funktionen zu übergeben
oder als Return-Werte zurück zu geben. Ein Anwendungsbereich für eine
solche Funktion könnte z.B. ein Callback sein, der auf einem Event
registriert wird.\\

Eine solche Funktion kann einerseits eine benannte Funktion sein,
auch eine die innerhalb einer Klasse oder einem Objekt definiert ist.
Falls sie jedoch nur zu diesem einen Zweck definiert wird, ist eine 
Benennung der Funktion überflüssig. Aus diesem Grund kann eine Funktion
auch \emph{anonym} erstellt und verwendet werden.\\

Erstellt kann eine Anonyme Funktion ziemlich einfach wie folgt:

\begin{lstlisting}[float=ht,language=scala,caption=Anonyme Funktion,label=lst:anonymousFunction]
(x: Int) => x + 1
\end{lstlisting}

Beispiel \ref{lst:timerAnonymous} zeigt eine Verwendung einer solchen 
anonymen Funktion, welche einem Timer übergeben wird und jede Sekunde
aufgerufen wird. \\

\subsection{Pattern Matching}

Ein wichtiges Konzept der Funktionalen Programmierung ist das Konzept
des Pattern Matching. Hierbei können Muster angegeben werden, nach denen 
die Eingabeparameter einer Funktion geprüft werden. Zusätzlich zu den
Mustern werden verschiedene Funktionen definiert. Es wird dann diejenige
Funktion ausgeführt, bei der das Muster auf die Eingabe zutrifft.\\

In Scala kann Pattern Matching auf sogenannte \emph{Case Classes} angewendet
werden. So können Funktionen erstellt werden, die sich je nach Eingabe,
sei es Typen oder Werte, anders verhalten.  Möchte man das gleiche
in Java erreichen, müsste man ein switch-Statement oder sogar eine
\glqq if-elseif-Verzweigung\grqq konstruieren, welches alle möglichen
Eingabewerte (unter Umständen mit \emph{instanceof}) überprüft.

Case-Classes können einfach erstellt werden, indem einfach das Keyword
\emph{case} vor die Klassendeklaration gestellt wird. \\

Um Pattern Matching etwas näher zu bringen, erstmal ein Beispiel einer
Funktion, welche verschiedene Eingabewerte \glqq matcht\grqq und dementsprechend
ein verschiedenes Verhalten an den Tag legt (dieses Beispiel kommt der 
Einfachheit halber ohne Case-Classes aus)

\begin{lstlisting}[float=ht,language=scala,caption=Pattern Matching auf Litale \cite{odersky},label=lst:patternMatching]
def describe (x: Any) = x match {
	case 5       => "five"
	case true    => "truth"
	case "hello" => "hi!"
	case Nil     => "the empty list"
	case _       => "something else" // Default
}
\end{lstlisting}

Ein wichtiger Vorteil gegenüber einer Implementation in Java mit
einem Switch-Statement und \emph{instanceof} sind sogenannte 
\emph{Constructor Patterns}. Hierbei kann nicht nur das Objekt selber
verglichen werden sondern auch dessen Inhalt. \\

Pattern Matching kommt oft dann zum Zug, wenn es um Baum-ähnliche
Datenstrukturen geht. Beispiel REF im Kapitel REF zeigt ein solches
Beispiel zusammen mit Case Classes.

\subsection{Closures}

Closures bilden ein Konzept in Funktionen, welches beim Aufruf der 
Funktion den Kontext, der bei der Erstellung der Funktion vorherrschte,
wiederherstellt. \\

Ein Beispiel soll dies verdeutlichen:

\lstset{float=ht,language=scala,caption={Eine Closure \cite{odersky}},label=lst:closures}
\lstinputlisting{src/Closures.scala}

Ausgeführt gibt dieses Beispiel den Wert 11 aus.

Obwohl die Variable \emph{more} im Kontext der Funktion nicht gebunden
wurde, funktioniert dieses Beispiel weil im Kontext der Erstellung eine
Variable \emph{more} existierte. Wird diese Variable nach der
Erstellung der Closure verändert, wird dies von der Closure bemerkt und 
der veränderte Wert verwendet. Umgekehrt wird eine Veränderung der
Variable innerhalb der Funktion auch nach aussen sichtbar.

\subsection{Currying}

Scala unterstützt das Konzept des Currying. Hierbei wird kann eine Funktion,
die \emph{n} Argumente erwartet, mit nur einem Argument aufgerufen werden. 
Daraus resultiert eine neue Funktion die nur noch \emph{n - 1} Argumente
erwartet und das bereits gegebene Argument fest enthält.\\

Folgend ein Beispiel, welches die Verwendung einer solchen Funktion
verdeutlicht: 

\lstset{float=ht,language=scala,caption={Eine Closure \cite{odersky}},label=lst:closures}
\lstinputlisting{src/Currying.scala}

Dieses Beispiel gibt das korrekte Resultat 5 aus.


\section{Typensystem}

\subsection{Typinferenz}

\section{XML}

\section{Threading}
