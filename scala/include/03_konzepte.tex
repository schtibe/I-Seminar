\chapter{Konzepte}

\section{Variablen}

Scala kennt zwei Keywords, um Variablen zu definieren: \emph{val} und 
\emph{var}. Der Unterschied besteht darin, dass eine Variable, die mit
\emph{val} definiert wurde, nicht mehr verändert werden kann. \emph{val}
ist also ähnlich wie eine \emph{final}-Variable in Java.

\section{Funktionen}


\section{Objektorientierung}

\subsection{Singleton-Objekte}

Da Scala eine Objektorientierte Programmiersprache ist, können nebst
den eingebauten Datentypen (\ref{sec:datatypes}) auch Klassen oder
Objekte definiert werden. Klassen haben die gleiche Funktionalität
wie in Java, mehr dazu unter \ref{sec:classes}.  Anders als in Java
ist die Möglichkeit, direkt Objekte zu definieren.  Dies kann mit dem
\emph{object}-Keyword erreicht werden, und entspricht dem Konzept des
allgemein bekannten Singleton-Pattern (es kann also nur eine Instanz davon
geben). Diese einmalige Instanz eines solchen Objekts wird beim ersten
Gebrauch automatisch kreiert. Ein wichtiger Unterschied zu Klassen ist,
dass ein solches Singleton-Objekt keine Parameter entgegen nehmen kann,
da es nicht manuell instanziert werden kann.

Ein Keyword wie \emph{static} in Java gibt es nicht. Anstatt Methoden
statisch zu implementieren, ist es in Scala üblich, Singleton-Objekte
zu definieren.\\

Ein Beispiel eines einfachen Singleton-Objekts bietet das Listing
\ref{lst:helloWorld} im Kapitel \ref{sec:helloWorld}.

TODO: referencing ist falsch, vor allem die Listings in 2 werden falsch gemacht.

\subsection{Klassen}
\label{sec:classes}

\subsubsection{Deklaration und Konstruktoren}

Klassen werden in einer Syntax deklariert die der von Java recht
ähnlich ist. Der Klassen-Body kann dabei dazu verwendet werden,
um Operationen bei der Instanzierung der Klasse auszuführen. In Java
wird dazu eine Konstruktor-Methode benötigt, in Scala hingegen können
diese Operationen einfach unter den Klassennamen geschrieben werden. \\

Ein Beispiel einer einfachen Klasse mit Konstruktor in Java
\lstset{float=ht,language=java,caption={Java-Konstruktor},label=lst:javaConstructor}
\lstinputlisting{src/Constructing.java}

würde in Scala wie folgt aussehen:
\lstset{float=ht,language=scala,caption={Scala-Konstruktor},label=lst:scalaConstructor}
\lstinputlisting{src/Constructing.scala}

Dies wird der \emph{primary constructor} benannt. Dem Programmierer steht es 
frei, noch weitere Konstruktoren zu definieren.


\subsubsection{Instanzierung}

Die Instanzierung von Klassen erfolgt analog zur Java-Syntax. So würde das 
Konstruktor-Beispiel im vorigen Kapitel (\ref{lst:scalaConstructor}) wie 
folgt instanziert werden:

\lstset{float=ht,language=scala,caption={Scala-Konstruktor},label=lst:scalaConstructor}
\lstinputlisting{src/TestConstructing.scala}

\subsubsection{Komposition und Vererbung}

Scala bietet alle nötigen Instrumente, um Klassen zu vererben und Subtypen
zu erstellen. Ebenfalls erstellt werden können abstrakte Klassen, finale
Klassen sowie finale Variablen. Kenner von Java finden sich mit den
entsprechenden Keywords für diese Konzepte schnell zurecht.\\

Ein Keyword, welches in Scala zusätzlich anzutreffen ist, ist 
\emph{override}. Falls ein Klassen-Member überschrieben werden soll,
muss dieses Keyword vor die Definition gestellt werden. Dies macht
ein versehentliches Überschreiben von Klassen-Member unmöglich.\\

Ein Umfangreiches Beispiel von Klassenvererbung und Komposition bietet
Beispiel TODO beispiel

\subsection{Traits}




\section{Funktionale Konzepte}

\subsection{Funktionen als Objekte und anonyme Funktionen}
\label{sec:functionsObjects}

Eines der grundlegenden Konzepte aus der Funktionalen Programmierung ist,
dass Funktionen auch Objekte sind. Dies macht es möglich, Funktionen
in Variablen zu speichern, sie als Argument an Funktionen zu übergeben
oder als Return-Werte zurück zu geben. Ein Anwendungsbereich für eine
solche Funktion könnte z.B. ein Callback sein, der auf einem Event
registriert wird.\\

Eine solche Funktion kann einerseits eine benannte Funktion sein,
auch eine die innerhalb einer Klasse oder einem Objekt definiert ist.
Falls sie jedoch nur zu diesem einen Zweck definiert wird, ist eine 
Benennung der Funktion überflüssig. Aus diesem Grund kann eine Funktion
auch \emph{anonym} erstellt und verwendet werden.\\

Beispiel \ref{lst:timerAnonymous} zeigt eine Verwendung einer solchen 
anonymen Funktion, welche einem Timer übergeben wird und jede Sekunde
aufgerufen wird. \\


\subsection{Pattern Matching}

\subsection{Closures}

\subsection{Currying}

\section{Typensystem}

\subsection{Typinferenz}

\section{XML}

\section{Threading}
