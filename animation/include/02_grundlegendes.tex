\chapter{Grundlegendes}

\section{Hallo Welt}
\label{sec:helloWorld}

Als erstes Beispiel soll, wie üblich, ein Hallo-Welt-Programm dienen:

\lstset{float=ht,language=scala,caption={Hallo Welt},label=lst:helloWorld}
\lstinputlisting{src/HelloWorld.scala}

Wie man sehen kann, ähnelt die Syntax der von Java. Darauf eingegangen
wird im Kapitel \ref{sec:syntax}. Das Keyword \emph{object} definiert
ein Singleton-Objekt (siehe \ref{sec:singleton}).
Die Definition der Main-Methode ist analog zur Main-Methode in
einer Java-Applikation.

\section{Kompilieren und Ausführen}

Scala bietet drei Möglichkeiten zum Ausführen von Code. Einerseits kann Scala
für umfangreiche Applikationen kompiliert werden. Dies wird durch den
Aufruf des Scala-Compilers \emph{scalac} erreicht. Dabei werden Dateien
mit der Endung \emph{.class} erstellt. Ausgeführt kann eine Applikation
schliesslich durch den Aufruf von \emph{scala}, bei dem der Klassenname 
ohne Dateiendung mitgegeben wird, wie bei Java:

\begin{lstlisting}[float=ht,language=bash,caption=Kompilieren und Ausführen von Scala-Code,label=lst:execute]
scalac HelloWorld.scala
scala HelloWorld
=> Hello World!
\end{lstlisting}

Eine andere Möglichkeit besteht darin, Scripts zu erstellen, welche dann
während der Laufzeit interpretiert und ausgeführt werden. Dazu kann
der Name der Datei direkt an \emph{scala} übergeben werden. Die Definition
einer Main-Methode wird hierbei nicht benötigt.\\

Die dritte Möglichkeit ist, interaktiv Scala-Code in den Interpreter 
einzugeben. Der Interpreter wird gestartet, wenn \emph{scala} ohne
Argumente aufgerufen wird.

\section{Syntaktische Grundlagen}
\label{sec:syntax}

Um die Beispiele in diesem Dokument verstehen zu können, muss kurz
auf die Syntax von Scala eingegangen werden. Im Allgemeinen ähnelt
sie der von Java, so werden z.B. Blöcke mit \{ \} eingeschlossen und
viele Keywords sind gleich (class, abstract, private, extends, ...).
Ein wesentlicher Unterschied besteht in der Angabe von Typen bei
Variablen und Funktionen, welches der Programmiersprache ML entlehnt
wurde: anstatt dass Typen wie in Java vor die Deklaration gestellt werden
(z.b. int foo;), werden Typen in Scala mit einem Doppelpunkt getrennt
\emph{hinter} die Deklaration gestellt. Folgend je ein Beispiel zu einer
Variable und einer Funktion mit Argumenten und einem Rückgabewert:

\begin{lstlisting}[float=ht,language=scala,caption=Typenangabe,label=lst:types]
var Number: Int
def Funktion(arg1: Int, arg2: String) : Boolean {} // Boolean ist der Rueckgabewert
\end{lstlisting}

Das Semikolon am Ende der Zeile kann in Scala ausgelassen werden, wenn nicht
mehrere Statements auf einer Zeile stehen.

\section{Datentypen}
\label{sec:datatypes}

Scala ist eine pure Objekt-Orientierte Sprache. Dies bedeutet, dass alles
ein Objekt ist, selbst Funktionen (siehe auch \ref{sec:functionsObjects}). Im
Gegensatz zu Java gibt es also auch keine primitiven Datentypen.\\

Eine Spezialität ist, dass arithmetische Operationen eigentlich
Methodenaufrufe auf den entsprechenden Datentypen darstellen. So wird
folgender Aufruf

\begin{lstlisting}[float=ht,language=scala,caption=Arithmetische Operationen,label=lst:arithmetic]
2 + 3 * 4
\end{lstlisting}

umgewandelt zu
\begin{lstlisting}[float=ht,language=scala,caption=Arithmetische Operationen konvertiert,label=lst:arithmeticConverted]
(2).+((3).*(4))
\end{lstlisting}

Ersichtlich wird hierbei, dass arithmetische Zeichen
als Methodennamen erlaubt sind. Dies erlaubt auch ein einfaches überschreiben
der Operatoren, wie dies bei C++ möglich ist.

\section{Integration mit Java}

Beim Kompilieren von Scala wird Bytecode erstellt, der in der Java
Virtual Machine ausgeführt wird. Dies ermöglicht eine weite Bandbreite
von unterstützten Plattformen. Dadurch können auch alle Java-Libraries
in Scala verwendet werden. \\
